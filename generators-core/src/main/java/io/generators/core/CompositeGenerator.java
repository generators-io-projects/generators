package io.generators.core;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableList;

import java.util.List;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.Lists.newArrayList;

/**
 * Returns  values generated by generators passed in and transformed by the aggregation function
 *
 * @author Tomas Klubal
 */
public class CompositeGenerator<I, T> implements Generator<T> {
    private final Function<List<I>, T> aggregationFunction;
    private final List<Generator<I>> stringGenerator;

    /**
     * Creates new generator.
     *
     * @param aggregationFunction function that aggregates values produced by the {@code generators}
     * @param generators          list of generators generating the values
     * @throws java.lang.NullPointerException when aggregation function is null
     * @throws java.lang.IllegalArgumentException when list of generators is null or empty
     *
     */
    public CompositeGenerator(Function<List<I>, T> aggregationFunction, List<Generator<I>> generators) {
        this.aggregationFunction = checkNotNull(aggregationFunction, "Aggregation function is mandatory");
        checkArgument(generators != null && !generators.isEmpty(), "No generators provided");
        this.stringGenerator = ImmutableList.copyOf(generators);
    }


    @Override
    public T next() {
        List<I> generatedValues = newArrayList();
        for (Generator<I> generator : stringGenerator) {
            generatedValues.add(generator.next());
        }

        return aggregationFunction.apply(generatedValues);
    }
}
