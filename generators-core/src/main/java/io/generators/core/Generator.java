package io.generators.core;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Stream;

import static com.google.common.base.Preconditions.checkArgument;

/**
 * Generates instance of &lt;T&gt;
 *
 * @author Tomas Klubal
 * @author David Bliss
 */
public interface Generator<T> {

    /**
     * Returns generated &lt;T&gt;
     *
     * @return generated <T>
     */
    T next();

    /**
     * Applies function {@code f} to all generated values.
     *
     * @param f   function to be applied
     * @param <U> functions result type
     * @return a new generator of type {@code U} resulting from applying the given function f to each generated  value
     */
    default <U> Generator<U> map(Function<T, U> f) {
        return () -> f.apply(next());
    }


    /**
     * Selects all values generated by this generator which satisfy a predicate.
     *
     * @param p the predicate used to test elements.
     * @return a new generator generating values that satisfy the given predicate p.
     */
    default Generator<T> filter(Predicate<T> p) {
        return () -> {
            T next;
            do {
                next = next();
            } while (!p.test(next));
            return next;
        };
    }


    /**
     * Applies function {@code f} to all generated values.
     *
     * @param f   function to be applied
     * @param <U> functions result type
     * @return a new generator of type {@code U} resulting from applying the given function f to each generated  value
     */
    default <U> Generator<U> flatMap(Function<T, Generator<U>> f) {
        return () -> f.apply(next()).next();
    }


    /**
     * Returns stream consisting of elements generated by this generator
     *
     * @return stream of elements of type {@code T}
     */
    default Stream<T> stream() {
        return Stream.generate(this::next);
    }


    /**
     * Converts Stream of T to Generator of T. Returned generator throws {@link java.util.NoSuchElementException} if there are no elements left in the stream and {@link Generator#next} is called
     *
     * @param stream of elements to be used for generation
     * @param <T>    type of the Stream and Generator values
     * @return Generator returning elements from the stream
     */
    static <T> Generator<T> from(Stream<T> stream) {
        return stream.iterator()::next;
    }

    /**
     * Returns supplier that supplies values generated by this generator
     *
     * @return supplier of values of type T
     */
    default Supplier<T> supplier() {
        return this::next;
    }

    /**
     * Creates new generator from the given supplier
     *
     * @param supplier of the generated values
     * @param <T>      type of the generated value
     * @return new generator
     */
    static <T> Generator<T> from(Supplier<T> supplier) {
        return supplier::get;
    }

    /**
     * Returns a generator generating same values as this generator, additionally
     * performing the provided action on each value as values are consumed
     * from the resulting generator.
     *
     * @param action a <a href="package-summary.html#NonInterference">
     *               non-interfering</a> action to perform on the elements as
     *               they are consumed from the generator
     * @return the new generator
     * @throws NullPointerException when action is null
     */
    default Generator<T> peek(Consumer<? super T> action) {
        Objects.requireNonNull(action, "action can't be null");
        return () -> {
            T next = next();
            action.consume(next);
            return next;
        };
    }

    /**
     * Returns possibly infinite Iterable
     *
     * @return the Iterable
     */
    default Iterable<T> toIterable() {
        return () -> new Iterator<T>() {
            @Override
            public boolean hasNext() {
                return true;
            }

            @Override
            public T next() {
                return Generator.this.next();
            }
        };
    }

    /**
     * Returns iterable that can be iterated up to the specified limit
     *
     * @param limit maximum size of the iterable (not necessary the size as in certain cases the generator can run out of the elements before reaching the limit)
     * @return the new iterable
     */
    default Iterable<T> take(long limit) {
        checkArgument(limit >= 0 , "limit must be >= 0 but it was %s", limit);
        return () -> new Iterator<T>() {
            private long cursor = 0;

            @Override
            public boolean hasNext() {
                return cursor < limit;
            }

            @Override
            public T next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                cursor++;
                return Generator.this.next();
            }
        };
    }


    /**
     * Indicates whether generator has finished generating values
     * @return true if there are no more values to generate
     */
    default boolean finished() {
        return false;
    }

    /**
     * Limits number of values that that this generator can generate (it can be less if some other method is used)
     * @param limit maximum number of generated values
     * @return finite generator
     */
    default FiniteGenerator<T> limit(long limit) {
        checkArgument(limit >= 0 , "limit must be >= 0 but it was %s", limit);
        Generator<T> self = this;
        return new FiniteGenerator<T>() {
            private long counter = 0;
            @Override
            public T next() {
                counter++;
                return self.next();
            }

            @Override
            public boolean finished() {
                return counter >= limit;
            }
        };

    }
}